# encoding: UTF-8

module Timely
  class Row
    class_attribute :default_options, instance_writer: false
    self.default_options = {}

    attr_accessor :title, :key, :scope, :options

    # Title: string or symbol for I18n lookup
    # Key: timestamp column name
    # Scope: (internal) Generated by the report
    # Options:
    #    cacheable: if true, cache past values in Redis
    #    transform: proc to apply to each value (e.g. for rounding), or pass
    #    `:round` to apply default rounding (two-decimal precision) or `:to_i`
    #    to round to 0 decimals
    def initialize(title, key, scope, options={})
      options.reverse_merge! default_options.reverse_merge(cacheable: true)

      self.title = title
      self.key = key
      self.scope = scope
      self.options = options
    end

    def title
      @title.is_a?(Symbol) ? I18n.t("timely.rows.#{@title}") : @title
    end

    def cache_key
      title.parameterize
    end

    def cacheable?
      !!options[:cacheable]
    end

    ## Values ##

    # override value or raw_value in subclasses
    def value(starts_at, ends_at)
      transform raw_value_from date_range_scope(starts_at, ends_at)
    end

    def total(ends_at)
      transform raw_value_from date_range_scope(nil, ends_at)
    end

    private

    # override in subclasses to perform a custom calculation
    def raw_value_from(scope)
      scope.count
    end

    private

    ## Helpers ##

    # helper function for rounding non-integer values for nicer output
    def round(val)
      val ? val.to_f.round(Timely.default_precision) : 0
    end

    # transform the given value using either one of the default
    # transformations (:round or :to_i) or a custom proc
    def transform(value)
      transform = options[:transform]

      if transform == :round
        round value
      elsif transform == :to_i
        value.round
      elsif transform
        transform.call(value)
      else
        value
      end
    end

    ## Scopes ##

    # only return records between the reporting dates
    def date_range_scope(starts_at, ends_at)
      starts = starts_at && key_is_date? ? starts_at.to_date : starts_at
      ends = ends_at && key_is_date? ? ends_at.to_date : ends_at

      if starts && ends
        scope.where("#{key_sql} >= ? AND #{key_sql} < ?", starts, ends)
      elsif starts
        scope.where("#{key_sql} >= ?", starts)
      elsif ends
        scope.where("#{key_sql} < ?", ends)
      else
        scope
      end
    end

    ## Column Names ##

    # if the column name does not specify the table, add the table name
    def disambiguate_column_name(col)
      col.include?(".") ? col : "#{scope.table_name}.#{col}"
    end

    def key_sql
      @key_sql ||= disambiguate_column_name key
    end

    # check if a date column's name ends in _on (vs. _at)
    def key_is_date?
      @key_is_date ||= (key =~ /_on\z/)
    end
  end
end